---
layout: ../../../layouts/BlogLayout.astro
title: "Node on Docker using AWS Fargate"
date: April 1, 2018
tags: ["aws","Continuous Delivery","Continuous Integration","docker","expressjs","fargate","Node","travis","typescript"]
excerpt: ""
---

## ExpressJS and TypeScript

JavaScript is the most popular language today which is evident in the surveys conducted by stackoverflow and github repository statistics. Another reason for the selection was a personal attachment I have to it by using it on a daily basis at my workplace. As the application gets bigger though, the need for static type checking also grows. On too many occasions, bugs were introduced because of parameter mismatch and unit testing doesn't cover this. Flow was our answer to this problem, but Typescript was used here for experiment sake. To get started, I just had to install it globally using npm: 
```
npm install -g typescript
```
 The basic build configuration for TypeScript looks as follows which should be stored in a file called tsconfig.json at the root level of the directory: https://gist.github.com/dejanvasic85/b276a5ff9e4baf59571377c4e33fafd7   The rest is very simple, at the root of the project a simple 
```
tsc
```
 command will transpile everything in to the dist folder. Application is so simple you can just check it out in the github repository: https://github.com/dejanvasic85/venue-api/tree/master/src

## **Docker**

Given all the cloud offerings today, there's obviously a variety of ways to write, test and deploy an application. For example, [serverless framework](https://serverless.com/) gives us an easy way to write [AWS lambdas](https://aws.amazon.com/lambda) that are deployed and exposed via an AWS Gateway which is pretty cool so docker doesn't have any part to play. Unfortunately, this would mean a vendor lock-in situation so it would be very difficult to migrate to another cloud provider. Hence, my choice of a deployment strategy supported by all providers. Docker! Docker with node, is so simple and lightweight that the docker file is simple as: https://gist.github.com/dejanvasic85/8b452242eeaab3e877617dabfcd89331 When I signed up to AWS, it was very simple steps to follow for building, tagging andpublishing it in the internal docker repository. But going a step further, travis should be able to do this for us.

## **Travis**

My choice to use travis was quite simple. It's free for open source projects and simple as a one toggle switch on my profile page. ![Screen Shot 2018-04-01 at 11.30.27 am](https://dejanvasic.wordpress.com/wp-content/uploads/2018/04/screen-shot-2018-04-01-at-11-30-27-am.png) This tells travis, on every commit to look for a 
```
.travis.yml
```
 file in the root directory of the repo. And oh boy, was this another simple thing to put together. By marking the language as 
```
node_js
```
, travis automatically knows to run commands such as 
```
npm install
```
 and 
```
npm test
```
. The other 'services' you can specify is docker which tells travis to ensure that it's installed. The after\_success part was not as straight forward but after a bit of googling it was quite simple in the end. We need ability to install the awscli so that we can login to the private repository and push the new image created by our travis build: https://gist.github.com/dejanvasic85/ab3750084481990e415eb7d0a27f26f0

> Hint: DO NOT ever commit your AWS keys especially in plaintext. Just use them as environment variables set in travis settings menu and mark them as secret which will not display their values during the build.

## Terraform

This is one of the biggest changes for me when it comes to application deployment compared to using Octopus Deploy. Although, [OD does support terraform deployment now](https://octopus.com/docs/deploying-applications/terraform-deployments). Terraform is a command line tool that also needs to be installed and available on your path. The change required for travis was to add a 
```
before_deploy
```
 because the service is not natively available like docker. This way, our terraform commands will be available in our travis script during the 
```
deploy
```
 step. https://gist.github.com/dejanvasic85/0e3874c8ddcc1830eec6c991db5ba81d Terraform is a simple infrastructure as a script so everything is described in a language called 
```
HCL
```
 which stands for HashiCorp Language (I think). But it's not very daunting to learn. In fact it's a really nice balance between a json file and a yml. The following are the things I would like to share which I learned from using terraform which I didn't find documentation had really helped me with:

### 1\. Please use a backend config stored in S3

What this means is that every time we execute terraform to 
```
plan
```
 or 
```
apply
```
 a deployment, it will store the state of the infrastructure as a file. But using a central storage like AWS S3, would mean that it can be executed all the time on any machine. You don't want be dependent on storage on a local machine somewhere. Now, to configure your backend this is what worked for me (after many attempts). I finally got it working! https://gist.github.com/dejanvasic85/f811e6f754c398f62cce94b96f0cb3d0 What I didn't like about this though, was that variable substitution doesn't work. So the region is actually hardcoded. This is one of the downsides I found in terraform. I still had to specify region a few times :(

### 2\. Use environment variables for AWS authentication

Terraform documentation shows that you can specify AWS keys in your scripts. Don't do this unless you want to be hit by a massive bill because bots have obtained your keys and deployed a huge number of servers that are probably running bitcoin mining operations. So, in my example I have a 
```
deploy.sh
```
 file which will execute terraform so that every time I execute it, I can set the keys in line during the execution like so: 
```
AWS_ACCESS_KEY_ID=xxx AWS_SECRET_ACCESS_KEY=xx ./deploy.sh
```
 When executing the deploy.sh file in travis, these keys should be available because I specified them and it works!

### 3\. Separate your environments in to folders

One main difference to using Octopus Deploy, is that we can now configure all our environment variables in actual source controlled files. I like this. It gives the developers full control and history of changes as part of Git history. However, it doesn't allow for "secrets" which makes things pretty tricky. There are solutions for this but I haven't had the chance to address it just yet. So, terraform does a nice explanation of how variables and files work. It's pretty sweet. My deploy.sh file looks like this: https://gist.github.com/dejanvasic85/999811e5a837fe2f70e8dcbd9ae0b72a So you can see, that the build number is used for building the docker image and then it's used as a special variable passed through to the terraform command. 
```
-var app_version=$BUILD_NUMBER
```
 That is a nice way to propagate the build number through :) Also. I like the use of the default bash script variables like the environment name which is then just used for string interpolation for the env file to use. Check out the 
```
-var-file
```
 parameter in the script above.

## Final Touches

One thing I spent a lot of time on is ensuring that the 
```
deploy
```
 script worked in Travis. Thank you so much to the following blog post: http://jongear.io/travis-script-deploy-gotcha/ So the special linux command 
```
chmod +x ./filename.sh
```
 before running the script does the trick to get rid of the travis permissions error. This helped me with my last section of the .travis.yml file: https://gist.github.com/dejanvasic85/1b2243e6ee7d3d2a068c4e72f65941ef

## Where is Fargate?

I didn't plan for this blog post to be so long... We'll leave it for next time. I quite like the idea of fargate. If EKS (kubernetes) on AWS was available, I'd probably use that instead because it seems to be making a lot more progress as it's opensource and now available on Azure and Google Cloud. However, neither Fargate nor EKS seem to be production ready. Therefore, if I was to push docker app to production on AWS, then I'd fall back to using ECS with managed EC2 instances.